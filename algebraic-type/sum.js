const { IArray, IObject } = require("./intrinsics");
const { inspect } = require("util");
const { isTaggedCall, tagResolve } = require("./templating");

const Instantiate = { };
const private = require("./private");
const f = require("./function-define");
const given = f => f();
const fail = require("./fail");
const Field = require("./field");


module.exports = function sum(name, fConstructors = [])
{
    const T = f.constructible(name, function (T, ...rest)
    {
        if (rest[0] !== Instantiate)
            return defaultConstructor === false ?
                fail(`Type ${name} has no default constructor.`) :
                defaultConstructor(...rest);

        const [_, constructor, args] = rest;

        private(this, "constructor", () => constructor);
        private(this, "values", () => args);

        return this;
    },
    type.prototype);

    const constructors = fConstructors.map(fConstructor => fConstructor(T));
    const constructorEntries = constructors
        .map(constructor => [constructor.name, constructor]);

    IObject.assign(T, IObject.fromEntries(constructorEntries));

    const [_, defaultConstructor] =
        constructorEntries.find(([key]) => key === name) ||
        [0, false];

    T.prototype[inspect.custom] = function (depth, options)
    {
        if (depth < -1)
            return "{ â€¦ }";

        const nextDepth = options.depth === null ? null : options.depth - 1;
        const inner = value => inspect(value, { ...options, depth: nextDepth });
        const Tname = T.name;
        const Cname = private(this, "constructor").name;

        const fullyQualified = Tname === Cname ? `${Tname}*` : `${T.name}.${Cname}`;

        // FIXME: if autogenerated inner type...
        // Or maybe just use * when its ONE item with the same name...
        return `${fullyQualified} { ${private(this, "values").map(inner)} }`;
    };

    const necessary = constructorEntries.map(([name]) => name);
    const necessarySet = new Set(necessary);

    T.prototype.match = function (cases)
    {
        return match.call(this, T, necessary, necessarySet, cases);
    }

    T.has = value => value instanceof T;

    T.case = (...arguments) =>
        isTaggedCall(arguments) ?
            (...definitions) =>
                sum(name,
                [
                    ...fConstructors,
                    toFConstructor(tagResolve(...arguments), definitions)
                ]) :
            arguments.length === 1 &&
            arguments[0] instanceof type ?
                sum(name,
                [
                    ...fConstructors,
                    toFConstructor(arguments[0].name, arguments.map(T => of => T))
                ]) :
            fail("NO.");

    return T;
}

function toFConstructor(name, definitions)
{
    if (definitions.length === 1 && typeof definitions[0] === "object")
    {
        const innerT = type `${name}` (definitions[0]);

        return forT => f (name, (f, values) =>
            new forT(Instantiate, f, [innerT(values)]));
    }

    // FIXME: Defer?
    // Defer for recursive?...
    const fields =  definitions.map(f => new Field(f()));

    return forT => f (name, (f, ...values) =>
        fields.map((field, index) => field.extract(forT, index, values)) &&
        new forT(Instantiate, f, values));
}

const type = require("./type");


// FIXME, This may be faster with bitsets, just loop each one and | together...
function match(T, necessary, necessarySet, cases)
{
    const hasDefault = IObject.has("default", cases);
    const present = IObject.keys(cases);
    const presentSet = new Set(IObject.keys(cases));
    const missing =
        !hasDefault && necessary.find(name => !presentSet.has(name));

    if (missing)
        fail(`${T.name}.match call is missing case for "${missing}".`);

    if (present.length > necessary.length)
        fail(
            `${T.name}.match call has non-constructor case ` +
            `"${present.find(name => !necessarySet.has(name))}".`);

    const target = private(this, "constructor").name;
    const handler = cases[target] || cases.default;

    return handler(...private(this, "values"));
}

/*
x.match
({
    Just: value => value,
    Nothing: () => 10,
    default: () => 20,
})
    .case `Just` (value => value);
    .case `Nothing` (() => 10);

function toCase(T, masks, visited, remaining)
{
    return function (args)
    {
        if (!isTaggedCall(args))
            fail("Missing constructor name in case statement");

        const name = tagResolve(...args);
        const mask = masks[name];

        if (!mask)
            fail(`Type ${T.name} has no constructor named ${name}.`);


        return uRemaining === 0 ?
            uAnswer :

        if (uRemaining === 0)
            return uAnswer;

            (...definitions) =>
                sum(name,
                [
                    ...constructors,
                    toConstructor(tagResolve(...arguments), definitions)
                ]):
            fail("NO.");


        if (!masks[]
        if (visited & )
    }
}
/*
    private(T, "constructors", constructors);

    IObject.assign(T, constructors
        .map( => [constructor.name, () => { type_check(); set; });
    .map(T => [T.name, T])),

    this.constructors =



Sum
    Name -> args []


const Arguments = product();
const Constructor = product("Constructor", { name: type.string, arguments: type });

function Constructor()
{
}

const type = require("./type");
const fNamed = (name, f) => Object.defineProperty(f, "name", { value: name });
const fPrototyped = (prototype, name, f) =>
    fNamed(name, Object.setPrototypeOf(f, prototype));


module.exports = (...types) => ({ construct, types });

function construct(T, instantiate, { types }, value)
{
    const match = types.find(T => type.belongs(T, value));

    if (!match)
        throw Error(`${value} didn't match internal ` +
                    `type: ${types.map(T => T.name).join(", ")}`);

    return fPrototyped(T.prototype, `${type.typename(T)}:${type.typename(match)}`, () => value);
}

function sum(name, definition)
{

}


Expression = sum(of => A, of => B, of => C);


data: {}
tuple: []
function(???):

type `tuple` ([of => A, of => B, of => C])

type `A` (of => A | B | C )

*/


        /*if (has_default_constructor) ||
            can_infer?
            return;

        Instantiate

        field_check(args)

        private(this, "values", () => args);

        this.innerThingy = x;

        return this;
        const values = hasPositionalFields ? args : args[0];

        return  values instanceof T ? values :
                values === Instantiate ? this :
                IObject.freeze(IObject.assign(
                    hasPositionalFields ?
                        IObject.setPrototypeOf([], T.prototype) :
                    this instanceof T ?
                        this :
                        new T(Instantiate),
                    IObject.fromEntries(fields(T)
                        .map(initialize(
                            T,
                            values || UseFallbackForEveryField)))));*/